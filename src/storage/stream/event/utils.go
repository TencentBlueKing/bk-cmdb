/*
 * Tencent is pleased to support the open source community by making 蓝鲸 available.
 * Copyright (C) 2017-2018 THL A29 Limited, a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"reflect"
	"regexp"
	"strings"

	"configcenter/pkg/filter"
	"configcenter/src/common"
	"configcenter/src/common/blog"
	"configcenter/src/common/json"
	"configcenter/src/storage/stream/types"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

const fullDocPrefix = "fullDocument."

var eventFields = []string{"_id", "operationType", "clusterTime", "ns", "documentKey", "updateDescription"}

func generateOptions(opts *types.Options) (mongo.Pipeline, *options.ChangeStreamOptions, *parsedCollOptsInfo) {
	collOptsInfo := parseCollOpts(opts.CollOpts)

	allFilters := genWatchFilter(collOptsInfo.collCondMap, collOptsInfo.collOpTypeMap)

	// if any options needs all fields, do not filter fields
	allFields := make([]string, 0)
	for _, fields := range collOptsInfo.collFieldsMap {
		if len(fields) == 0 {
			allFields = make([]string, 0)
			break
		}
		allFields = append(allFields, fields...)
	}

	var pipeline mongo.Pipeline
	if len(allFilters) != 0 {
		pipeline = []bson.D{{{Key: "$match", Value: allFilters}}}
	}

	if len(allFields) != 0 {
		project := make(map[string]int)
		for _, f := range allFields {
			project[fullDocPrefix+f] = 1
		}

		// add default event fields, otherwise, these fields will not be returned.
		for _, f := range eventFields {
			project[f] = 1
		}

		pipeline = append(pipeline, bson.D{{Key: "$project", Value: project}})
	}

	streamOptions := new(options.ChangeStreamOptions)
	if opts.MajorityCommitted != nil {
		if *opts.MajorityCommitted {
			major := options.UpdateLookup
			streamOptions.FullDocument = &major
			preImage := options.WhenAvailable
			streamOptions.FullDocumentBeforeChange = &preImage
		} else {
			def := options.Default
			streamOptions.FullDocument = &def
		}
	}

	if opts.MaxAwaitTime != nil {
		streamOptions.MaxAwaitTime = opts.MaxAwaitTime
	}

	if opts.StartAfterToken != nil && opts.StartAtTime == nil {
		streamOptions.SetStartAfter(opts.StartAfterToken)
	}

	if opts.StartAfterToken == nil && opts.StartAtTime != nil {
		streamOptions.SetStartAtOperationTime(&primitive.Timestamp{
			T: opts.StartAtTime.Sec,
			I: opts.StartAtTime.Nano,
		})
	}

	// if all set, then use token to resume after, this is accurate.
	if opts.StartAfterToken != nil && opts.StartAtTime != nil {
		streamOptions.SetStartAfter(opts.StartAfterToken)
	}

	// set batch size, otherwise,
	// it will take as much as about 16MB data one cycle with unlimited batch size as default.
	var batchSize int32 = 2000
	streamOptions.BatchSize = &batchSize

	return pipeline, streamOptions, collOptsInfo
}

// parsedCollOptsInfo is the parsed watch task and collection info generated by collection options
type parsedCollOptsInfo struct {
	// taskTypeMap is watch task id to event data type map
	taskTypeMap map[string]reflect.Type
	// taskFilterMap is watch task id to filter map
	taskFilterMap map[string]*filter.Expression
	// collRegexMap is collection regex string value to collection regex expression map
	collRegexMap map[string]*regexp.Regexp
	// collRegexTasksMap is collection regex to watch task ids map
	collRegexTasksMap map[string][]string
	// collCondMap is collection regex to merged data filter condition map
	collCondMap map[string]*filter.Expression
	// collOpTypeMap is collection regex to merged operation types map
	collOpTypeMap map[string][]types.OperType
	// collFieldsMap is collection regex to merged fields map
	collFieldsMap map[string][]string
}

// parseCollOpts parse collection options to parsedCollOptsInfo
func parseCollOpts(collOpts map[string]types.WatchCollOptions) *parsedCollOptsInfo {
	// generate watch task and collection mapping info by collection filter watch options
	info := &parsedCollOptsInfo{
		taskTypeMap:       make(map[string]reflect.Type),
		taskFilterMap:     make(map[string]*filter.Expression),
		collRegexMap:      make(map[string]*regexp.Regexp),
		collRegexTasksMap: make(map[string][]string),
		collCondMap:       make(map[string]*filter.Expression),
		collOpTypeMap:     make(map[string][]types.OperType),
		collFieldsMap:     make(map[string][]string),
	}

	for id, opt := range collOpts {
		// generate watch task and collection mapping info
		info.taskTypeMap[id] = reflect.Indirect(reflect.ValueOf(opt.EventStruct)).Type()
		info.taskFilterMap[id] = opt.Filter
		regex := opt.CollectionFilter.Regex
		info.collRegexMap[regex] = regexp.MustCompile(regex)
		info.collRegexTasksMap[regex] = append(info.collRegexTasksMap[regex], id)

		// merge collection condition with the same collection regex
		cond := opt.Filter
		collCond, exists := info.collCondMap[regex]
		if exists {
			if collCond == nil {
				cond = nil
			} else if cond != nil {
				cond = &filter.Expression{RuleFactory: &filter.CombinedRule{Condition: filter.Or,
					Rules: []filter.RuleFactory{collCond, cond}}}
			}
		}
		info.collCondMap[regex] = cond

		// select all operation type if any options needs all types, otherwise, return types specified by all options
		collOpTypes, exists := info.collOpTypeMap[regex]
		if !exists || len(collOpTypes) != 0 {
			if opt.OperationType == nil {
				info.collOpTypeMap[regex] = make([]types.OperType, 0)
			} else {
				info.collOpTypeMap[regex] = append(collOpTypes, *opt.OperationType)
			}
		}

		// select all fields if any options needs all fields, otherwise, return fields specified by all options
		collFields, exists := info.collFieldsMap[regex]
		if !exists || len(collFields) != 0 {
			if len(opt.Fields) == 0 {
				info.collFieldsMap[regex] = make([]string, 0)
			} else {
				info.collFieldsMap[regex] = append(collFields, opt.Fields...)
			}
		}
	}

	return info
}

// genWatchFilter generate watch filter by collection to condition and operation type map
func genWatchFilter(collCondMap map[string]*filter.Expression, collOpTypeMap map[string][]types.OperType) bson.D {
	allFilters := make([]bson.D, 0)
	noFilterCollRegexes := make([]string, 0)
	for regex, cond := range collCondMap {
		// if the collection regex has no condition and no operation type filter, add to noFilterCollRegexes
		if len(collOpTypeMap[regex]) == 0 && cond == nil {
			noFilterCollRegexes = append(noFilterCollRegexes, regex)
			continue
		}

		// generate filter for collection regex with special condition
		filters := bson.D{{Key: "ns.coll", Value: bson.M{common.BKDBLIKE: regex}}}

		if len(collOpTypeMap[regex]) > 0 {
			filters = append(filters, bson.E{Key: "operationType", Value: bson.M{common.BKDBIN: collOpTypeMap[regex]}})
		}

		if cond != nil {
			mongoFilter, err := cond.ToMgo()
			if err != nil {
				blog.Errorf("convert coll(%s) filter(%s) to mongo filter failed, err: %v, skip", regex, cond, err)
				continue
			}
			for k, v := range mongoFilter {
				filters = append(filters, bson.E{Key: fullDocPrefix + k, Value: v})
			}
		}

		allFilters = append(allFilters, filters)
	}

	// merge all no filter collection regexes to one collection regex filter
	if len(noFilterCollRegexes) != 0 {
		allFilters = append(allFilters, []bson.E{
			{Key: "ns.coll", Value: bson.M{common.BKDBLIKE: strings.Join(noFilterCollRegexes, "|")}},
		})
	}

	if len(allFilters) == 0 {
		return make(bson.D, 0)
	}
	if len(allFilters) == 1 {
		return allFilters[0]
	}
	return bson.D{{Key: common.BKDBOR, Value: allFilters}}
}

// parseCollInfo parse collection info
func parseCollInfo(collection string) (types.CollectionInfo, error) {
	tenantID, parsedColl, err := common.SplitTenantTableName(collection)
	if err != nil {
		blog.Errorf("split collection %s failed, err: %v", collection, err)
		return types.CollectionInfo{}, err
	}

	return types.CollectionInfo{
		Collection: collection,
		ParsedColl: parsedColl,
		TenantID:   tenantID,
	}, nil
}

// parseDataForTask parse event data for task, returns event data and matched flag
func parseDataForTask(rawDoc bson.Raw, taskID string, taskFilterMap map[string]*filter.Expression,
	taskTypeMap map[string]reflect.Type) (*types.Event, bool) {

	// decode event data and get json value
	doc := reflect.New(taskTypeMap[taskID]).Interface()
	if err := bson.Unmarshal(rawDoc, doc); err != nil {
		blog.Errorf("decode to struct: %T failed, err: %v, data: %s", doc, err, rawDoc)
		return nil, false
	}
	byt, _ := json.Marshal(doc)

	// check if event data matches watch filter
	if expr, exists := taskFilterMap[taskID]; exists && expr != nil {
		matched, err := expr.Match(filter.JsonString(byt))
		if err != nil {
			blog.Errorf("check if event data(%s) matches watch filter(%s) failed, err: %v", string(byt), expr, err)
			return nil, false
		}

		if !matched {
			return nil, false
		}
	}

	return &types.Event{
		Document: doc,
		DocBytes: byt,
		TaskID:   taskID,
	}, true
}
