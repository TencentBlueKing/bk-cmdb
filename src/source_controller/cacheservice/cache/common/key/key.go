/*
 * Tencent is pleased to support the open source community by making
 * 蓝鲸智云 - 配置平台 (BlueKing - Configuration System) available.
 * Copyright (C) 2017 THL A29 Limited,
 * a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 * We undertake not to change the open source license (MIT license) applicable
 * to the current version of the project delivered to anyone in the future.
 */

// Package key defines the cache key generator logics
package key

import (
	"errors"
	"fmt"
	"math/rand"
	"strings"
	"time"

	"configcenter/src/storage/dal"
	"configcenter/src/storage/stream/types"
)

var allKeyInfo = make(map[KeyType]KeyGenerator)

func addKeyGenerator(typ KeyType, generator KeyGenerator) {
	generator.typ = typ
	allKeyInfo[typ] = generator
}

// GetAllKeyGenerator get all key type -> cache key generator map
func GetAllKeyGenerator() map[KeyType]KeyGenerator {
	return allKeyInfo
}

// GetKeyGenerator get cache key generator from key type
func GetKeyGenerator(typ KeyType) (KeyGenerator, error) {
	key, exists := allKeyInfo[typ]
	if !exists {
		return key, fmt.Errorf("cache key type %s is invalid", typ)
	}
	return key, nil
}

// KeyGenerator is the common resource cache key generator
type KeyGenerator struct {
	// typ is the cache key's type
	typ KeyType
	// namespace is the cache key's namespace
	namespace string
	// watchOpt is the mongo watch options
	watchOpt types.Options
	// expireSeconds is the ttl for the key.
	// it's always used with the expireRangeSeconds to avoid the keys to be expired at the same time, which
	// will have large numbers of request flood to the mongodb, we can not accept that.
	// for example, if expireSeconds is 30min, expireRangeSeconds is [-600, 600], then
	// a key's expire seconds is between [20, 40] minutes.
	expireSeconds time.Duration
	// min range:expireRangeSeconds[0], max range:expireRangeSeconds[1]
	expireRangeSeconds [2]int
	// idGen generates redis id field and score
	idGen func(data interface{}) (string, float64, error)
	// keyGenMap is the mapping of key kind to the key generator
	keyGenMap map[KeyKind]redisKeyGenerator
	// dataGetterMap is the mapping of key kind to the db data getter
	dataGetterMap map[KeyKind]dataGetter
}

// redisKeyGenerator generates redis key suffix from data
type redisKeyGenerator func(data interface{}) (string, error)

// dataGetter get mongodb data by redis keys
type dataGetter func(db dal.DB, keys ...string) ([]interface{}, error)

// Type returns the cache key's type
func (k KeyGenerator) Type() KeyType {
	return k.typ
}

// DetailKey is the redis key to store the resource detail, can only be generated by id
func (k KeyGenerator) DetailKey(id string) string {
	return k.namespace + "detail:" + id
}

// DetailLockKey is the redis key to lock the detail key related operations
func (k KeyGenerator) DetailLockKey(id string) string {
	return k.namespace + "detail:lock:" + id
}

// ListDoneKey is the redis key indicating that the list phase is complete
func (k KeyGenerator) ListDoneKey() string {
	return k.namespace + "listdone"
}

// IDListKey is a redis zset(sorted set) key to store all the host ids, which is used to paged host id quickly,
// without use mongodb's sort method, which is much more expensive.
// this key has a expired ttl.
// We use the host id as the default zset key's score, so that we can use host id as score and page's
// sort fields to sort host.
func (k KeyGenerator) IDListKey() string {
	return k.namespace + "id_list"
}

// WithRandomExpireSeconds generate random redis key expire in seconds
func (k KeyGenerator) WithRandomExpireSeconds() time.Duration {
	rand.Seed(time.Now().UnixNano())
	seconds := rand.Intn(k.expireRangeSeconds[1]-k.expireRangeSeconds[0]) + k.expireRangeSeconds[0]
	return k.expireSeconds + time.Duration(seconds)*time.Second
}

// GetWatchOpt get mongodb watch options
func (k KeyGenerator) GetWatchOpt() types.Options {
	return k.watchOpt
}

// GetAllKeyKinds get all cache key supported key kinds except for id kind
func (k KeyGenerator) GetAllKeyKinds() []KeyKind {
	keyKinds := make([]KeyKind, 0)
	for kind := range k.keyGenMap {
		keyKinds = append(keyKinds, kind)
	}
	return keyKinds
}

// GenerateRedisKey generate redis key
func (k KeyGenerator) GenerateRedisKey(kind KeyKind, data interface{}) (string, error) {
	if data == nil {
		return "", errors.New("data is nil")
	}

	suffix, err := k.keyGenMap[kind](data)
	if err != nil {
		return "", err
	}

	return k.namespace + string(kind) + ":" + suffix, nil
}

// GetIDKey get id key from data
func (k KeyGenerator) GetIDKey(data interface{}) (string, float64, error) {
	if data == nil {
		return "", 0, errors.New("data is nil")
	}
	return k.idGen(data)
}

// GetMongoData get mongodb data
func (k KeyGenerator) GetMongoData(kind KeyKind, db dal.DB, keys ...string) ([]interface{}, error) {
	keyLen := len(keys)
	if keyLen == 0 {
		return nil, errors.New("keys are not set")
	}

	if keyLen > 500 {
		return nil, errors.New("keys exceeds maximum limit")
	}

	suffixes := make([]string, keyLen)
	for i, key := range keys {
		suffixes[i] = strings.TrimPrefix(key, k.namespace+string(kind)+":")
	}

	data, err := k.dataGetterMap[kind](db, suffixes...)
	if err != nil {
		return nil, err
	}
	return data, nil
}
