/*
 * Tencent is pleased to support the open source community by making
 * 蓝鲸智云 - 配置平台 (BlueKing - Configuration System) available.
 * Copyright (C) 2017 THL A29 Limited,
 * a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 * We undertake not to change the open source license (MIT license) applicable
 * to the current version of the project delivered to anyone in the future.
 */

package general

import (
	"fmt"
	"math/rand"
	"strconv"
	"strings"
	"time"

	"configcenter/src/common"
)

// Key is the general resource cache key
type Key struct {
	// resource is the cache key's resource type
	resource ResType
	// namespace is the cache key's namespace
	namespace string
	// expireSeconds is the ttl of the general resource detail cache key.
	// It is always used with expireRangeSeconds to avoid simultaneous expiration of cache keys,
	// which will cause a cache avalanche and a large number of direct requests to mongodb.
	// For example, if expireSeconds is 30min and expireRangeSeconds is [-600, 600],
	// then the cache key will expire between [20, 40] minutes.
	// NOTE: since this cache is also used by event watch, the expiry time should be the same with the event ttl
	expireSeconds time.Duration
	// min range: expireRangeSeconds[0], max range: expireRangeSeconds[1]
	expireRangeSeconds [2]int

	hasSubRes bool
	needOid   bool

	// IDKey generates the id key and score in id list cache by id and oid
	IDKey        idKeyGenerator
	genDetailKey detailKeyGenerator
}

// NewKey new Key
func NewKey(resource ResType, expireSeconds time.Duration, expireRangeSeconds [2]int, genIDKey idKeyGenerator,
	genDetailKey detailKeyGenerator) *Key {

	_, hasSubRes := ResTypeHasSubResMap[resource]
	_, needOid := ResTypeNeedOidMap[resource]

	return &Key{
		resource:           resource,
		namespace:          fmt.Sprintf("%s%s:", common.BKCacheKeyV3Prefix, resource),
		expireSeconds:      expireSeconds,
		expireRangeSeconds: expireRangeSeconds,
		hasSubRes:          hasSubRes,
		needOid:            needOid,
		IDKey:              genIDKey,
		genDetailKey:       genDetailKey,
	}
}

// Resource returns the cache key's resource type
func (k *Key) Resource() ResType {
	return k.resource
}

// DetailKey returns the general resource detail redis key generated by id key and extra keys
func (k *Key) DetailKey(tenantID string, idKey string, key ...string) string {
	return k.namespace + "detail:" + tenantID + ":" + k.genDetailKey(idKey, key...)
}

// UniqueKey generates a unique key of the specified type, this cache key stores the unique identifier of the resource
func (k *Key) UniqueKey(typ, tenantID, key string) string {
	return k.namespace + typ + ":" + tenantID + ":" + key
}

// IDListKey is a redis zset(sorted set) key to store all the related data ids, which is used to page id quickly,
// without use mongodb's sort method, which is much more expensive.
// This key's ttl is defined where it is used, it might not be the same with the detail cache's ttl.
// NOTE: if the resource has sub resource, the id list key must contain the sub resource
func (k *Key) IDListKey(tenantID string, key ...string) string {
	if len(key) == 0 {
		return k.namespace + "id_list:" + tenantID
	}
	return k.namespace + "id_list:" + tenantID + ":" + strings.Join(key, ":")
}

// IDListTempKey is used to store the id list during refresh,
// it will be renamed to IDListKey() after all the ids are written to the temp key.
func (k *Key) IDListTempKey(idListKey string, rid ...string) string {
	if len(rid) == 0 {
		return strings.Replace(idListKey, "id_list", "id_list:temp", 1)
	}
	return strings.Replace(idListKey, "id_list", "id_list:temp", 1) + "-" + rid[0]
}

// IDListExpireKey stores the id list expire timestamp, it is used to judge if the id list needs refreshing
// the id list has a longer ttl and is refreshed with special logics to avoid blocking redis operations when it expires
func (k *Key) IDListExpireKey(idListKey string) string {
	return strings.Replace(idListKey, "id_list", "id_list:expire", 1)
}

// IDListLockKey is used to lock the id list during refresh
func (k *Key) IDListLockKey(idListKey string) string {
	return strings.Replace(idListKey, "id_list", "id_list:lock", 1)
}

// WithRandomExpireSeconds generate random redis key expire in seconds
func (k *Key) WithRandomExpireSeconds() time.Duration {
	rand.Seed(time.Now().UnixNano())
	seconds := rand.Intn(k.expireRangeSeconds[1]-k.expireRangeSeconds[0]) + k.expireRangeSeconds[0]
	return k.expireSeconds + time.Duration(seconds)*time.Second
}

// HasSubRes returns if the resource has sub resource
func (k *Key) HasSubRes() bool {
	return k.hasSubRes
}

// NeedOid returns if the resource needs oid to generate the id key
func (k *Key) NeedOid() bool {
	return k.needOid
}

// idKeyGenerator is the id key generator, returns the id key and score for id list cache
type idKeyGenerator func(id int64, oid string) (string, float64)

func genIDKeyByID(id int64, _ string) (string, float64) {
	return strconv.FormatInt(id, 10), float64(id)
}

func genIDKeyByOid(_ int64, oid string) (string, float64) {
	return oid, 0
}

// detailKeyGenerator is the detail key generator, returns the unique key for detail cache
type detailKeyGenerator func(idKey string, key ...string) string

func genDetailKeyWithoutSubRes(idKey string, _ ...string) string {
	return idKey
}

func genDetailKeyWithSubRes(idKey string, subRes ...string) string {
	if len(subRes) == 0 {
		return ""
	}
	return subRes[0] + ":" + idKey
}
